% !TEX root=../report.tex

\Chapter{Electron}

Electron (formerly known as Atom Shell \cite{atomShell}) is an open-source framework developed and maintained by GitHub \cite{electron}. It is based on the Chromium V8 browser engine \cite{chromium} and the Node.js JavaScript runtime \cite{nodejs}. The Electron framework was initially developed for the Atom text editor \cite{atom} in 2013 and both were open-sourced in the beginning of 2014 \cite{aboutElectron}.

Electron enables a developer to build cross-platform applications which are written in \gls{html}, \gls{css}, and \gls{js}. Its \gls{api} offers desktop integration with \gls{api}s such as the OSX and Windows notifications, the Windows taskbar, the Ubuntu launcher and many more. With this framework, it is possible to maintain a single code-base while serving all major desktop operating systems, as well as hosting a website on a traditional web server.

\Section{Electron's Architecture}

Every Electron application has a main file which is the root or starting point for the application. This file is specified in the package.json configuration file with the key \enquote{main}. By convention, this file is called \enquote{main.js}, but any name is possible.

This main file is mostly used to set event handlers on the app object. These include handlers for the \enquote{ready}, \enquote{window-all-closed}, and \enquote{activate} events (see \myautoref{lst:main-ready.js}). Also the event handler for the ready event usually contains code to create a \lstcode{BrowserWindow} object and load some \gls{html}. In the Jukebox project, the main.js file is used for the entire application startup sequence as well as for some Electron debugging methods.

\file{main-ready.js}{The Jukebox app \enquote{ready} event handler.}{JavaScript}

Electron uses the multi-process architecture of its underlying Chromium V8 engine. This means that the main.js file is called from the main process but every \enquote{web page} is running in a separate window and process, which is called a renderer process \cite{electronAppArch}. \myautoref{fig:electronArch.png} illustrates the multi-process architecture.

\image[scale=.2]{electronArch.png}{Electron architectural overview. \cite{electronArch}}

There is exactly one main process at all times. It is responsible for managing all of the renderer processes. A renderer process only knows its web page and is isolated from the rest of the application. It is thightly coupled to the \lstcode{BrowserWindow} object. If the window is destroyed, the process is also terminated.

\Subsubsection{Inter-process Communication}

As all renderer processes are isolated from the main process as well as each other, there needs to be a way to communicate data between those processes. This is done via the Electron \gls{ipc} \gls{api} which is split into the \lstcode{ipcMain} and \lstcode{ipcRenderer} objects, which are both instances of \lstcode{EventEmitter}.

\file{ipcMain.js}{Handling messages with the ipcMain module. \cite{ipcMain}}{JavaScript}

The \lstcode{ipcMain} is only accessible in the main process. It is used to handle asynchronous as well as synchronous messages sent from a renderer process (\myautoref{lst:ipcMain.js}). To handle messages the \lstcode{ipcMain.on()} method is used. Its first argument is a string which is referred to as \enquote{channel} and used as a key. The same channel has to be used for the sender and the receiver. The second argument is a delegate which takes an event object as well as many arguments. This delegate will be executed every time a renderer process sends a message using the specified channel.

The \lstcode{ipcMain} object also provides several other methods, \zB a method to execute a listener only once, another method to remove a single or all listeners. As shown in \myautoref{lst:ipcMain.js} the main process can reply via the \lstcode{event.returnValue} property which results in a synchronous message. It could also send a new message to the renderer which would be an example of an asynchronous communication. The \lstcode{ipcMain} object does not contain a send method like the \lstcode{ipcRenderer}, since it would not be clear where to send the message. Instead, the \lstcode{webContents} object of a given \lstcode{BrowserWindow} provides this method. This is the same object held by the \lstcode{event.sender} property. \cite{ipcMain}

The \lstcode{ipcRenderer} object is only available inside a renderer process and is similar to the \lstcode{ipcMain} object. The only notable differences are the \lstcode{send} methods. It is possible to send asynchronous as well as synchronous messages. The \lstcode{ipcRenderer.send()} method always sends the message to the main process. If the message needs to be sent to a different renderer process, the \lstcode{ipcRenderer.sendTo()} method may be used. \cite{ipcRenderer}

\gls{ipc} was used in the Jukebox project to quit the application from the taskbar item. This was neccessary since the \lstcode{app} object is only available within the main process, but the system tray is set up inside an Angular service class which runs in a renderer process. Also, \gls{ipc} may be used if results of a dialog have to be communicated back to the main application.

\Subsubsection{App}

Electron's \lstcode{app} object provides access to the application's lifecycle events, as well as properties which hold information about the application. This includes methods to manipulate the Windows jumplist in order to add items to the taskbar context menu. It is possible to import certificates, get application metrics, access the OSX dock, or get the application's root folder path. In the Jukebox project, this was used for the notifications and system tray functionalities and will be described in more detail in the corresponding sections.

\Subsubsection{Node}

Node.js is a \gls{js} runtime environment which offers libraries for a variety of typical desktop application tasks. The Jukebox project uses mostly the \enquote{fs} and \enquote{os} libraries.

The \enquote{fs} library grants access to the filesystem \cite{nodejsFS}. It was used to check that the Windows start menu folder for this application exists and if not, create it (\mylineref{lst:setupWindowsNotifications.js}{swn_fs}). Without the \gls{asp} server this library would  be used to access the music files.

The \enquote{os} library provides access to operating system specific information and methods \cite{nodejsOS}. This was used to determine the current operating system and architecture to be able to register the correct notification libraries.

\Section{Accessing Electron APIs from within Angular}

One of the challenges in the Jukebox project was accessing the Electron \gls{api}s from within Angular. This access was needed for setting the menus and their corresponding \lstcode{click()} handlers, as well as showing notifications or determining the current environment.

\Subsubsection{require('electron')}

The first approach was to try and \lstcode{import} or \lstcode{require()} the Electron package. This, however, failed due to configuration errors. Angular can be configured via system.js or webpack, but the developer rarely gets to see or manipulate these files, since they are generated by the Angular \gls{cli} during the build only. It is possible to \enquote{eject} the webpack configuration file and change it to be able to \lstcode{require()} the Electron package. However, this is rather complicated and creates problems with other packages, since the Angular \gls{cli} does not automatically adapt the configuration file anymore. \cite{electronRequireError}

\Subsubsection{ngx-electron}

The alternative to \lstcode{require('electron')} is to use the ngx-electron package \cite{ngxElectron}. This package provides an Angular service, the \lstcode{ElectronService}, which is exposed as an interface and contains properties for all of the Electron \gls{api}s.

This package checks the user agent property to determine whether the application is running inside Electron. If it is, the Electron package is \lstcode{required()}. If not, all properties of the \lstcode{ElectronService} return \lstcode{undefined}, except for the \lstcode{isElectronApp} property. This property returns a \lstcode{boolean} and makes it simple to check whether the application is running inside Electron or as a web page in some browser.

\Section{Menus}

A big difference between web pages and traditional desktop applications are menues. Web applications often integrate menues into the web page sometimes as navigation bars sometimes at prominent locations in the layout. For desktop applications the placement of the menu is rather clear. For Windows applications it is a menu bar right under the top border of your application window and for Ubuntu (Unity) and OSX it is also a menu bar but located at the top of your screen. Electron offers \gls{api}s for the traditional menu.

\Subsubsection{Application Menu}


For the Jukebox project a custom \lstcode{MenuItem} class was created, the \lstcode{AngularMenuItem}. This is due to the fact, that a menu is needed in the pure web version as well as in the desktop version. With this approach the custom class can be used for the entire project and only a small part, namly the \lstcode{MenuItemService}, has to know the Electron \gls{api}s. Since Electron is doing some initialization it is not possible to use a custom \lstcode{MenuItem} even if the custom \lstcode{MenuItem} has the same signature. Therefore a converter method was implemented, as shown in \myautoref{lst:createElectronMenuItem.ts}. This method creates an instance of \lstcode{Electron.MenuItem} for each \lstcode{AngularMenuItem} recursively.

\file{createElectronMenuItem.ts}{Excerpt of the Jukebox MenuItemService class.}{JavaScript}

\Subsubsection{Systemtray}

Another form of menu is the system tray and its menu. Especially for applications which are supposed to run in the background and only show a notification if an event occurs, the ability to minimize it to the system tray is important. Electron supports this with the \lstcode{Electron.remote.Tray} \gls{api}. For this a picture has to be set and then a menu may be specified.

\file{trayMenuTemplate.ts}{Example of a menu template.}{JavaScript}

In the Jukebox project the system tray menu was implemented using templates, as shown in \myautoref{lst:trayMenuTemplate.ts}. This means an array of anonymous objects is created which all follow a certain signature. The properties of these objects are then read by the Electron framework and a \lstcode{Electron.MenuItem} is created using this blueprint. The advantages are that the developer only has to specify the properties needed for this menu item and the framework can ignore additional properties. Therefore it is possible to use existing custom objects in this array, without the need of implementing interfaces.

\Subsubsection{Challenges while implementing Menus}

One issue was that of routing from a menu item. Many menu items are used to navigate through the application \zB to get to the settings page. In Angular routing is usually done via the \lstcode{Router.navigateByUrl()} method. If the \lstcode{click()} handler of a menu item was set to just this line of code a navigation would occur but the old page would still be displayed and the new page would be displayed beneith it.

Angular uses zone.js to enable its \lstcode{<router-outlet />} feature of exchanging parts of the web page at runtime and manage different execution context's \cite{zoneJS}. Since the \lstcode{click()} event handler is called from the Electron framework it is beeing called from a different context which is causing this weired behavior.

To fix this a reference to the \lstcode{NgZone} object is needed which can be obtained through injection. The \lstcode{click()} handler then has to be modified to run the navigation code in the corresponding zone, as shown in \myautoref{lst:zoneNavigation.ts}.

\file{zoneNavigation.ts}{Fixed \lstcode{click()} handler.}{JavaScript}

Another issue is that of top level menu items not behaving correctly. This is an ongoing issue and results in top level items ignoring the change of values of the \lstcode{enabled} and \lstcode{visibile} properties. There is no fix for this currently. \cite{topMenuItems}

\Section{Notifications}

Electron provides a basic \gls{api} for all operating systems to send notifications to the user. This is done through the \gls{html} 5 notification \gls{api}.


The globally available \lstcode{Notification} object is used to manage a websites permission to display notifications. This is done through the static \lstcode{Notification.permission} property which returns one of the three following values: \enquote{granted}, \enquote{denied}, \enquote{default}. The \enquote{default} values tells the developer that the user choice is unknown at this moment. In this state the browser behaves as if the user denied permission which results in no notifications beeing shown. With the static \lstcode{Notification.requestPermission()} method the user is asked whether he want to see netofications or not.

\file{html-notification.ts}{Displaying a basic HTML notification.}{JavaScript}

Once permission is granted a notification can be displayed as shown in \myautoref{lst:html-notification.ts}.

\Subsection{Windows}

\file{setupWindowsNotifications.js}{TODO think of title}{JavaScript}

\Subsection{Linux}
\Subsection{Mac}
