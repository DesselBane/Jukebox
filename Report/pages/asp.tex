% !TEX root=../report.tex

\Chapter{ASP.NET Core}

\gls{asp} is a cross-platform, open-source framework for building cloud- and web-based applications. It is the latest of Microsoft's web frameworks. Although the name is very similar to the ASP.NET framework, \gls{asp} is not its 5th version, but a new framework rewritten from the ground up. It combines the previously independent ASP.NET MVC and ASP.NET Web API frameworks into one single programming model. It uses the new .NET Core framework which is platform-independent, but projects may also target the Windows-only .NET framework. \cite{introASP}

\Subsubsection{NuGet}

The \gls{asp} framework relies on the NuGet Package Manager for its modularity. The NuGet Package Manager is very similar to Node's \gls{npm}. The packages to be used in a project can either be configured using the command line, or directly editing the *.csproj file, or using the \gls{gui} tools most .NET Core \gls{ide}s provide. This makes it possible to download the necessary parts of the \gls{asp} framework only. Microsoft also allows third parties to publish libraries on its NuGet platform. This was also done in the Jukebox project for some of the middlewares.

\Subsubsection[owin]{OWIN}

\gls{owin} is another big aspect of \gls{asp}'s modularity. \gls{owin} is not a specific implementation, but rather a specification which helps developers to create a modular architecture and was used to create the \gls{asp} framework. Katana is the codename Microsoft gave its \gls{owin} implementation and should not be confused with \gls{owin} itself.

The most important concept for a developer is that of a middleware. In the \gls{owin} specification, a middleware is defined as an exchangeable programming block with the following signature: \lstcode{Func<IDictionary<string, object>, Task>}. This means a middleware is a delegate which is given an \lstcode{IDictionary} object containing key-value-pairs and which has to return a \lstcode{Task} object. By using a \lstcode{Task}, Microsoft enables programmers to take advantage of the \gls{tpl} and its asynchronous programming model \cite{tpl}.

Middlewares are usually provided by the \gls{asp} framework, or they can be created by the developer for specific tasks. In order to create a middleware the developer has two options. He may simply create a delegate with the correct signature. Since this is similar to functional programming, Microsoft also provided a method to use classes. When a class is used, the \gls{asp} framework will check whether this class contains a method which matches the signature of a middleware. Using this method, the developer may take advantage of \gls{di} for any dependencies the custom middleware requires. \cite{owinKatana}

Another concept defined by the \gls{owin} standard is the middleware pipeline. Every \gls{http} request will traverse this pipeline and be processed along the way. A request is often referred to as context and is contained in the \lstcode{IDictionary} object of the middleware delegate. Depending on the circumstances, a middleware might alter the request and call the next middleware, or complete the request. Each request starts at the first middleware. Yet not every request reaches the last middleware, since it might be processed before it gets to the end. Once a request is processed, it travels back to the beginning of the pipeline. This is illustrated in \myautoref{fig:owin-middleware-chain.png}.

\autoImg{owin-middleware-chain.png}{Example of an OWIN middleware pipeline. \cite{owinKatana}}

\Subsubsection{The \lstcode{Program} class}

Like any other C\# project, an \gls{asp} project is rooted in the \lstcode{Program} class and its \lstcode{Main()} method. As of .NET Core 2.x, the code required to start a \lstcode{WebHost} has been simplified, as shown in \myautoref{lst:main.cs} \cite{aspFundamentals}. In the Jukebox project, the \gls{url} is explicitly defined. It is still possible to configure options like the \gls{iis} integration, a custom content root path, and many more through the \lstcode{WebHostBuilder} class. Any configuration through the \lstcode{WebHostBuilder} will overwrite the configuration \revMark{specified} via the launchSettings.json file.

The underlying web server of \gls{asp} is called Kestrel. It is a minimalistic web server which only provides three features. Those are HTTPS, Websockets, and Unix sockets for high performance behind Nginx. Kestrel should never be used as a standalone solution, but rather in combination with another web server like \gls{iis}, Nginx or Apache \cite{kestrel}.

\file{main.cs}{The \lstcode{Main()} method of the Jukebox project.}{NC_CSharp}


\Subsubsection{The \lstcode{Startup} Class}

The \lstcode{Startup} class is used to configure an \gls{asp} application. It is separated into two methods: the \lstcode{ConfigureServices()} and the \lstcode{Configure()} method. This class is called \lstcode{Startup} by convention, but may be named differently. If a another name is chosen, the developer has to specify it via the \lstcode{WebHostBuilder.UseStartup<T>()} method as shown in \myautoref{lst:main.cs}. The \lstcode{Startup} class does not implement any interfaces. The \gls{asp} framework detects the required methods via reflection. This is necessary since these methods have multiple applicable signatures, which are handled differently by the framework.

\gls{di} is an integral part of the \gls{asp} framework and is configured in the \lstcode{ConfigureServices()} method. This method has one parameter of type \lstcode{IServiceCollection} which is an interface similar to the Autofac \lstcode{Container\-Builder} class. In order to make classes and framework parts available, such as the \gls{mvc} functionality of \gls{asp}, they have to be registered using this interface.

The \lstcode{IServiceCollection} interface provides many features which are sufficient for most projects, but it is not possible to configure interception using this interface. If the developer needs or wants to use interception, he has to change the signature of the \lstcode{ConfigureServices()} method to return an \lstcode{IServiceProvider} interface. This interface is Microsoft's abstraction of a \lstcode{Container} class which is used to resolve dependencies. The Jukebox project uses the Autofac \gls{di} framework was used, because it supports all of \gls{asp}'s \gls{di} interfaces \cite{autofacCoreDoc}. It should be noted that it is also possible to use other \gls{di} frameworks, but custom adapters may have to be implemented \cite{aspCustomDI}.

The Jukebox project uses a dual approach. \gls{asp} components are registered via the \lstcode{IServiceCollection} interface because extension methods are provided by the framework. All other classes are registered using the \lstcode{ContainerBuilder} class to enable interception. Then all registrations from the \lstcode{IServiceCollection} interface are transferred to the \lstcode{ContainerBuilder} using the \lstcode{Populate()} method. Finally, a \lstcode{IServiceProvider} is created using the  \lstcode{AutofacServiceProvider} class. This is illustrated in \myautoref{lst:configureJukebox.cs}. \revMark{warum abgeschnitten ?}

\file{configureJukebox.cs}{Configuring the \lstcode{IServiceCollection} in combination with an Autofac \lstcode{ContainerBuilder}.}{NC_CSharp}

Once all components are registered, the \gls{asp} framework calls the \lstcode{Configure()} method. This method is used to build the \gls{owin} middleware pipeline. Its first argument is of type \lstcode{IApplicationBuilder} and is required. The second and third arguments are of type \lstcode{IHostingEnvironment} and \lstcode{ILog\-gerFactory}, respectively, and are optional.

The \lstcode{IApplicationBuilder} interface is used to set up the pipeline, as shown in \myautoref{lst:configure.cs}. \gls{asp} provides extension methods for all of the framework's middlewares. There are multiple options to register a custom middleware. The \lstcode{IApplicationBuilder.Run()} method can be used to specify a delegate which will run and terminate the pipeline at this point. In order to chain middlewares the \lstcode{IApplicationBuilder.Use()} method can be used. This method also takes a middleware delegate as parameter. The \lstcode{IApplicationBuilder.UseMiddleware<T>()} method is used for middlewares which are written as a class. \cite{aspMiddleware}

It is important to bear in mind that the middleware which is registered first, will always be called first by the framework for each request that is processed. This means that the authentication middleware should always be registered before the \gls{mvc} middleware, otherwise requests might not be authenticated properly. In the Jukebox project, the \lstcode{ExceptionMiddleware} is registered first since it is supposed to catch any exception thrown in the pipeline later on. Next, the \lstcode{Swagger} and \lstcode{SpaMiddleware} are added because they do not require authentication. These are followed by the \lstcode{Authentication}, \gls{mvc}, and \lstcode{WebSocket} middlewares. Finally, the \lstcode{StaticFiles} middleware is added.

\newpage

\file{configure.cs}{Building the OWIN middleware pipeline.}{NC_CSharp}

\Section{ASP.NET MVC Core}


Middlewares are a great concept, but developing an entire application on the basis of just middlewares is very tedious. To make the development of web applications easier \gls{asp} offers the pre-built \gls{mvc} middleware. This middleware allows the developer to write his code in separate, independent classes which know nothing about \gls{owin} or the concept of a middleware. As the name suggests, using the \gls{mvc} middleware encourages the developer to implement his classes following the Model-View-Controller pattern. The \gls{mvc} package has to be registered with the \gls{di} container, as shown in \myautoref{lst:configureMvc.cs}.

\gls{mvc} is a popular pattern in software development and consists of three main components: Model, View, and Controller (\myautoref{fig:mvc.png}). The model represents the state of the application and any business logic or operations needed. All visual elements and any logic to manipulate these elements are considered the view. In the \gls{asp} context the Razor view engine is used to embed .NET code in \gls{html} markup. This allows for easy manipulation of the view. The controller is responsible for handling user interactions. It decides which view to render, and which methods to call in order to manipulate the model. In case of the Jukebox project, the view part was not used since all view-related actions are located inside the Angular code. \cite{mvcOverview}

\image[scale=.5]{mvc.png}{Main components of the MVC pattern. \cite{mvcOverview}}

\Subsubsection{Jukebox MVC configuration}

The \lstcode{AddMvc()} extension method offers the possibility to configure the \gls{mvc} middleware. In the Jukebox project, authorization handling and controller registration are configured explicitly.

To prevent unauthorized access, the \gls{mvc} package offers many ways to protect certain routes, also called actions. A developer may accept the default security settings or choose between filters and attributes to protect certain routes. It is important to note that the \gls{mvc} package does not authenticate or authorize any request at all. Another middleware is used specifically for this purpose. The \gls{jwt} Bearer middleware is the one used in the Jukebox project (see \myref{subsubsec:jwt}). \gls{mvc} only checks the \lstcode{HttpContext} to know whether and how a request is authorized, and then acts accordingly. By default, every route is unprotected. However, certain actions should only be executable if the request is authorized. There are two common solutions to this problem. First, a blacklist approach, where every route is accessible by default and the protected ones are declared explicitly. In this case, the developer uses the \lstcode{[Authorize]} attribute on any controller method which needs to be protected. The second option is to use a whitelist approach, where every route is protected by default and the unprotected routes are specified explicitly. As shown in \myautoref{lst:configureMvc.cs}, a filter is created using the \lstcode{AuthorizationPolicyBuilder} class and is applied to all routes. Then, all routes which shall be accessible without authorization are marked with the \lstcode{[AllowAnonymous]} attribute. The whitelist approach is used in the Jukebox project.

There are two ways of registering controllers for the \gls{mvc} package. By default, the \gls{mvc} package registers all classes with the \gls{di} container that are derived from the abstract \lstcode{Controller} base class and are located in the \enquote{Controllers} folder. If more functionality, such as interception, is needed, the \lstcode{AddControllersAsServices()} configuration option can be used, see \mylineref{lst:configureMvc.cs}{confMvc_controller}. This option forces the developer to register all controller classes explicitly. For the controllers registered in the Jukebox project, an interceptor is configured. This interceptor checks for null references passed to controller methods. If such a null reference is detected, the interceptor will throw a specific exception which results in a 400 \gls{http} response (see \myref{subsubsec:exceptionMiddleware}).

\file{configureMvc.cs}{Registering the MVC package.}{NC_CSharp}


\Subsubsection[mappingUrls]{Mapping URLs}

Mapping a \gls{url} to a controller action works either by convention or by explicit configuration. If nothing is specified, the convention is to map a \gls{url} to the controller's name followed by the method's name. For example the \enquote{/Home/Authors} \gls{url} is mapped to the \lstcode{HomeController} and its \lstcode{Authors()} method. Custom conventions may be specified when the \gls{mvc} middleware is added to the middleware pipeline. As shown in \myautoref{lst:mapRoute.cs}, a default route is created, which maps to the \lstcode{HomeController} and its \lstcode{Index()} method.

\file{mapRoute.cs}{A custom route mapping convention. \cite{routeConvention}}{NC_CSharp}

Attributes are another way of explicitly configuring mappings. The \lstcode{[Route]} attribute is used for controllers only. This attribute was used in the Jukebox project, since all controllers are supposed to be part of the \enquote{api/} route. The \lstcode{[Route]} attribute also offers macros. With macros it is possible to use the same attribute for all controllers: \lstcode{[Route("api/[controller]/[action]")]}. The \lstcode{[controller]} macro tells the framework to use the name of the controller which is decorated by the \lstcode{[Route]} attribute. Similarly, the \lstcode{[action]} macro references the name of the method or its custom-specified route.

For methods, also called actions, there are several attributes which are derived from the abstract \lstcode{HttpMethodAttribute} class. There is a matching attribute for each \gls{http} verb, \zB \lstcode{[HttpPost]}, \lstcode{[HttpGet]}, and so forth. Their main purpose is to specify the \gls{http} verb, in addition they include a template option to configure the \gls{mvc} mapping. This is neccessary to decide which method should be called on the controller if two \gls{url}s only differ in their \gls{http} verbs. A custom route is specified as a parameter in the \gls{http} verb attribute, \zB \lstcode{[HttpPost("my/custom/route")]}. Also, many \gls{rest} \gls{api}s use integers in the \gls{url} to reference a business object by its ID. This is supported through the curly bracket notation. A possible scenario is: some method should be executed on the \lstcode{Player} object with ID 11. This could be mapped to a \gls{url} like \enquote{/api/player/11/doSomething} and would result in an attribute such as \lstcode{[HttpPost("\{playerId\}/doSomething")]}. \\ \cite{mvcRouting}



\Subsubsection{Transfering Data}

Especially in case of a web \gls{api}, the transfer of data is very important. The most common options to transfer data via a \gls{http} request are: sending the data in the \gls{http} body, embedding the data into the \gls{url} using a query string, or inserting IDs into the \gls{url} as described in \myref{subsubsec:mappingUrls}. For small bits of information like a \lstcode{string} or \lstcode{int}, the query string method is recommended. The \lstcode{[FromQuery]} attribute tells \gls{asp} that a method argument should be mapped to a query string argument, see \mylineref{lst:dataTransfer.cs}{dataT_query}. In this case the annotated argument's name must match the key in the query string.

For the transfer of objects or large amounts of data the \gls{http} body should be used. In this case the \lstcode{[FromBody]} attribute indicates that data from the \gls{http} body shall be parsed, as shown in \mylineref{lst:dataTransfer.cs}{dataT_body}. Usually, the data is transferred as a \gls{json} string, but it is also possible to use \gls{xml}. \gls{asp} automatically tries to parse the \gls{json} string into an object of the specified type, in this example an object of type \lstcode{PlayerCommand}.

\file{dataTransfer.cs}{Different data transfer methods in ASP.NET Core.}{NC_CSharp}

For the Jukebox project, many classes like the \lstcode{PlayerCommand} class were written. These classes are referred to as a \gls{dto} and are usually \lstcode{sealed} classes which only contain properties and constructors. Each \gls{dto} is annotated with the \lstcode{[DataContract]} attribute and every property to be serialized is annotated with the \lstcode{[DataMember]} attribute. Some properties are used to convert data from one type to another. These are not annotated with the \lstcode{[DataMember]} attribute and are therefore ignored during serialization. This works well for most data types, the only exception are enums. Enums are serialized as integers by default, because the integer is the underlying type of a default enum in C\#. The default behavior can be changed with the \lstcode{[JsonConverter(typeof(StringEnumConverter))]} attribute to serialize an enum as a string. This improves readability on the front-end part and provides compatibility for the \gls{ts} implementation of an enum. \cite{mvcModelBinding}

\Section{Security in ASP.NET Core}

Securing an application against data leaks and malicious activity is especially important for a web application as it is accessible to a wide range of people. In \gls{asp} the security aspect consists of two topics: authentication and authorization.

\Subsubsection{ASP.NET Core Authentication}

Authentication is the process in which a client proves that he is the one he claims to be. Traditionally, a client will provide a username and a password. The server will check them against a database and decide whether the client has provided valid credentials or not. This basic form of authentication is possible in \gls{asp} and is mostly referred to as \enquote{cookie authentication}. Its benefit is its simplicity, but the drawback is its inflexibility. With the \gls{asp} Identity package the developer can choose between using a simple username-password combination or an external login provider such as Facebook, Google, Microsoft Account, Twitter, or others. This approach utilizes the OAuth 2.0 \cite{oauth2} or OpenID Connect \cite{openID} standards. \cite{identityStorageProviders}

\Subsubsection[jwt]{JWT Bearer Token Authentication}

\glslocalreset{jwt}

For the Jukebox project, the \gls{jwt} Bearer authentication was chosen \cite{jwt}. \gls{jwt} is an open standard for securely transmitting information in a self-contained, compact \gls{json} object. The information is secured either using the symmetric \gls{hmac} algorithm \cite{hmac}, or one of the asymmetric algorithms, namely \gls{rsa} or \gls{ecdsa} \cite{ecdsa}. \gls{jwt} was chosen because not only does it yield a token the server uses to authenticate a client, but it also transmits authorization information. This is especially important because the front-end can use this information to hide parts of the application depending on the user's level of authorization.

Configuring the \gls{jwt} package is a multi-step procedure. First, the \lstcode{TokenVali\-dationParameters} are set, as shown in \myautoref{lst:configureJwt.cs}. Then, a \lstcode{JwtTokenOptions} object is configured (\myautoref{lst:configureJwtTokenOptions.cs}) and a method for creating a \gls{jwt} token is implemented (\myautoref{lst:generateBasicAuthToken.cs}). Finally, the \gls{jwt} package is added to the middleware pipeline using the \lstcode{app.UseAuthentication()} extension method.

For the \lstcode{TokenValidationParameter}, a \lstcode{SymmetricSecurityKey} object is created which must be identical to the key object that is used to validate a \gls{jwt} token later on. Then, an \enquote{Issuer} and an \enquote{Audience} are set, both are optional. This serves the purpose of identifying the application (issuer) and the client (audience). Finally, the option to validate the lifetime of a token is set to \lstcode{true} and the clock skew is set to zero. \cite{jwtTokenAuth}

\file{configureJwt.cs}{Configuration of the JWT package.}{NC_CSharp}

The \lstcode{JwtTokenOptions} object was written specifically for the Jukebox project, it stores information needed to create new \gls{jwt} tokens. It consists of properties for the \enquote{Issuer} and the \enquote{Audience}. Furthermore, there are properties which define the expiration of the \gls{jwt} token, as well as the expiration of its refresh token. Finally, the \lstcode{JwtTokenOptions} object contains the \lstcode{SigningCredentials} which consist of the key and an enum to determine the algorithm to be used. As shown in \myautoref{lst:configureJwtTokenOptions.cs}, the \gls{hmac} algorithm is used in the Jukebox project.

\file{configureJwtTokenOptions.cs}{Configuration of the \lstcode{JwtTokenOptions}.}{NC_CSharp}

The last step in setting up the \gls{jwt} authentication package is to create a method which issues a new token. This method, shown in \myautoref{lst:generateBasicAuthToken.cs}, is part of the \lstcode{JwtAuthenticationService} in the Jukebox project. A \lstcode{ClaimsIdentity} object and a \lstcode{JwtTokenOptions} object are passed into the method. \lstcode{ClaimsIdentity} is the C\# object to manage a user in a claims-based authorization system, as described in \myref{subsubsec:claimsAuth}. First, a list of claims is instantiated. For this list, the \gls{jwt} Subject \enquote{Sub}, \gls{jwt} ID \enquote{Jti}, and Issued At \enquote{Iat} claims are created. The \gls{jwt} subject claim usually contains the username or email address. The \gls{jwt} ID claim contains a unique identifier, in the Jukebox project a \gls{guid} is used. The Issued At claim contains the current timestamp in \gls{utc} time. Then all claims stored in the \lstcode{ClaimsIdentity} are added to the claims list. These are claims defined by the web application and could contain a claim which grants access to the administrative section of the application. Then, a \lstcode{JwtSecurityToken} object is created. The \lstcode{JwtTokenOptions} are used to set the expiration, the issuer, and so on. Next, a refresh token is created. For the sake of simplicity, the Jukebox project uses a \gls{guid} as a refresh token. Finally, an \lstcode{AuthToken} \gls{dto} object is created which is used to send the information back to the client. So far, the \lstcode{JwtSecurityToken} is a C\# object which still needs to be serialized into a \gls{json} string. The serialization is handled by the \lstcode{JwtSecurityTokenHandler.WriteToken()} method. Both the \lstcode{JwtSecurityToken} and the \lstcode{JwtSecurityTokenHandler} classes are provided by the \gls{jwt} package.

\newpage

\file{generateBasicAuthToken.cs}{Generating the JWT Token.}{NC_CSharp}

\Subsubsection[claimsAuth]{Claims-Based Authorization}

After a client is authenticated, the \gls{jwt} token will be read and all claims will be extracted. These claims are used to check whether the client is authorized to execute an action. A claim describes an individual right or action this client possesses. It can also be proof of a piece of information about the client, such as his email address, birth date, or phone number.

Two custom claims are implemented in the Jukebox project. First, the \lstcode{UsernameClaim} which is used to store the username of a client. Second, the \lstcode{RoleClaim}. This claim is used to identify a client as \enquote{SystemAdmin}, \enquote{IndexAdmin}, or \enquote{PlayerAdmin} and grants permission to execute certain actions. Claims will be serialized when they are sent to the client inside the \gls{jwt} token. To identify a claim after it has been serialized, the claim needs a unique type which is saved as a string. By convention, a \gls{url} is used. For example the \enquote{http://Jukebox/Claims/Security/Username} string is assigned to the \lstcode{UsernameClaim} type in the Jukebox project. \cite{claimsBasedAuth}

\Section{Custom Middlewares}

The Jukebox project uses two custom middlewares. One is the \lstcode{ExceptionMid\-dleware} which translates custom exceptions thrown further down the middleware pipeline into \gls{http} responses. The other is the \lstcode{SpaMiddleware} which is needed to enable deep links into a \gls{spa}.

\Subsubsection[exceptionMiddleware]{ExceptionMiddleware}

The \lstcode{ExceptionMiddleware}, shown in \myautoref{lst:exceptionMiddleware.cs}, is the first middleware in the \gls{owin} pipeline. This middleware encloses the rest of the pipeline in a try-catch block which catches any \lstcode{InvalidRestOperationEx\-ception}s that are thrown. The \lstcode{InvalidRestOperationException} class is an abstract base class for exceptions like the \lstcode{NoContentException} (\gls{http} 204), \lstcode{ForbiddenException} (\gls{http} 403), and many more. Every exception derived from the \lstcode{InvalidRestOperationException} is required to implement the abstract \lstcode{ResponseCode} property which specifies the \gls{http} status code to be returned. Furthermore, the \lstcode{InvalidRestOperationException} contains a \lstcode{CustomErrorCode} property. This property is of type \gls{guid} and has to be set via a constructor argument.

Once such an exception is thrown, it will be caught in the catch block of the middleware. In this catch block, the \lstcode{StatusCode} property of the \lstcode{HttpContext\allowbreak .Response} object is set to the \lstcode{ResponseCode} property of the \lstcode{InvalidRestOp\-er\-a\-tionException}. Then, an \lstcode{ExceptionDTO} object will be created which contains the error message and error \gls{guid}. Although the exception class is already marked as \lstcode{[Serializable]}, this extra object is used in order to transmit only the error message and \gls{guid} - contrary to an exception which is serialized with its stack trace and other debug information not relevant in this scenario. Finally, the \lstcode{ExceptionDTO} will be serialized to a \gls{json} string and sent to the client.

\file{exceptionMiddleware.cs}{The \lstcode{ExceptionMiddleware}.}{NC_CSharp}


\Subsubsection{SpaMiddleware}

\glslocalreset{spa}

\gls{asp} is intended for use in combination with the Razor view engine to create traditional web applications. A \gls{spa} works quite differently, because there only exists one \gls{html} file for the entire application instead of one file for every subsite. Additionally, the front-end framework, in this case Angular, oftentimes comes with its own routing component. This means that a user might see a \gls{url} like \enquote{http://jukebox/account/settings}. This \gls{url} is used by the front-end framework to display the settings component, but the back-end knows nothing about such a \gls{url} and therefore would return a \gls{http} 404 error code.

These \glspl{url} are called deep links and are used by many web applications. The \lstcode{SpaMiddleware} is a piece of code which enables the deep link feature for web applications hosted via \gls{asp}. It has to be added to the middleware pipeline before the \gls{mvc} middleware and, since no authentication is needed, should also be added before any authentication middleware. As shown in \myautoref{lst:spaMiddleware.cs}, the middleware checks every request's \gls{url} to determine whether it is a deep link or not.

Whether a \gls{url} is a deep link or not is determined by a set of rules. Most importantly, the middleware checks whether the request has a file extension or not. This is needed because the index.html file references other files such as the bundle.js file. Furthermore, a configuration object is used. This configuration object stores paths which are not deep links because they are part of another middleware or feature of the web server. The Jukebox project uses the Swagger web \gls{api} documentation tool which can be accessed through the \gls{url} \enquote{http://jukebox/swagger} \cite{swagger}. Therefore, the Swagger \gls{url} is not recognized as a deep link but as a \enquote{SpecialRoute}, which causes the middleware to pass the request further down the pipeline.

When a deep link is found the middleware sets the \gls{http} status code to 200 OK and returns the index.html file. First attempts to solve this problem used a redirect mechanism to serve the index.html. This worked to the extent that the index.html file was served, but failed overall, because the deep link was lost due to the redirect. Since redirecting is not possible, the \lstcode{SpaMiddleware} needs to know where the index.html file is located. This can be achived by convention or explicit configuration. The middleware checks the \gls{asp} ContentRoot folder whether it contains a file called \enquote{index.html} without distinguishing between upper and lower case. If no file is found and none is specified through the \lstcode{PathToIndex} property on the configuration object, an exception is thrown.

\newpage

\file{spaMiddleware.cs}{The \lstcode{SpaMiddleware}.}{NC_CSharp}

\Section{Entity Framework Core}

\glslocalreset{ef}

To manage its users and song index, the Jukebox project uses the \gls{ef} \cite{efCore}. \gls{ef} is an \gls{orm} framework which enables developers to work with databases using .NET objects and programming paradigms like Fluent \gls{api}. It also eliminates the need to write \gls{sql} code. \gls{ef} features many different database providers to access \gls{mysql}, \gls{mssql}, SQLite, and many other database engines.

\Subsubsection{SQLite}
For the Jukebox project, a datastore was needed, but an entire database server would have been too unwieldy in its configuration and maintenance. Therefore, the SQLite database engine was chosen \cite{sqlite}. SQLite is a self-contained, file-based database engine which does not require any server application to connect to. Compared to a \gls{mssql} or a \gls{mysql} database engine, there are some limitations \cite{sqliteLimitations}, but these features are not needed in the Jukebox project.

\Subsubsection{Configuration}

When configuring a database with \gls{ef}, the developer may choose between the \enquote{Model-First-Approach} and the \enquote{Code-First-Approach}. In the \enquote{Model-First-Approach} an \gls{er} is created and saved as a *.edmx file. The developer can manipulate this model via \gls{gui} tools. The *.edmx file is then used to create a class structure which represents the database. This approach, however, requires an \gls{ide} which supports *.edmx modeling files. Also, it lacks flexibility because the classes created from the model are not meant to be edited, yet the \gls{gui} tools oftentimes limit functionality.

The \enquote{Code-First-Approach} is more widely used and also the recommended way of configuring a database with \gls{ef} \cite{efCreateModel}. This approach is more tedious, because the developer will have to implement all classes instead of having them generated by the \gls{ef} code generation tool. The advantage is a far greater control over the model. This approach offers the developer three options for the configuration of his database: Annotations, Fluent \gls{api}, and/or accepting the default conventions.

The easiest way is to accept the default conventions. For example, \gls{ef} will use properties which are called \enquote{Id} as a primary key, create foreign keys for properties of types registered in the \lstcode{DbContext}, and use the class name as the table name \cite{efConventions}. This method is appropriate for small databases or test dummies.

The second option is to use DataAnnotations (\myautoref{lst:song.cs}). These are attributes placed on properties which instruct the framework to handle these properties in a special way. Examples for annotations are the \lstcode{[Key]}, \lstcode{[ForeignKey]}, and \lstcode{[NotMapped]} attributes. This method works well for configuring columns and tables.

\file{song.cs}{Configuration of the \lstcode{Song} class using DataAnnotations.}{NC_CSharp}

The third method is to use the Fluent \gls{api} (\myautoref{lst:songConfiguration.cs}). The \lstcode{DbContext} abstract base class contains a protected virtual method called \lstcode{OnModelCreating()}. This method has to be overwritten to use the Fluent \gls{api}. Its only argument is of type \lstcode{ModelBuilder} and is used to access the \lstcode{EntityTypeBuilder<T>} configuration objects. These \lstcode{EntityTypeBuilder<T>} objects are then used to configure properties as primary keys, set the table name, configure the \lstcode{CascadeOnDeletion} option, and many other settings. Using the Fluent \gls{api}, anything related to the database can be configured, but the drawback is its obscurity since a developer cannot know how an entity is configured by simply looking at the entity class.

\file{songConfiguration.cs}{Configuration of the \lstcode{Song} class using Fluent API.}{NC_CSharp}

A mixture of all three approaches has proven to be more practical than sticking to just one. The default conventions are used to recognize properties which are called \enquote{Id} as primary keys. Properties which are not part of the database, but part of the C\# class, are annotated with the \lstcode{[NotMapped]} attribute and everything else is configured using the Fluent API.

\Subsubsection{Migrations}

An application's data model will grow during the development of the application. \gls{ef} supports changes in the data model with its migrations feature. A new migration can be created using the command line tools with the command \lstcode{dotnet ef migrations add <migrationName>}. Similiarly, the \lstcode{remove} command can be used to remove a migration. With the \lstcode{add} command \gls{ef} will create a migration class and then update the model snapshot class. The model snapshot class is used as a base line for comparison when a new migration is added. The created migration class contains code which describes the differences between the old model, as detailed in the snapshot, and the current model, as specified in the class structure. Every migration is derived from the abstract base class \lstcode{Migration} and has to implement the abstract \lstcode{Up()} and \lstcode{Down()} methods. As shown in \myautoref{lst:migration.cs}, the \lstcode{Up()} method contains instructions on how to apply the migration and the \lstcode{Down()} method contains instructions on how to revert the migration. \cite{efMigrations}

There are two ways to apply one or more migrations. The first solution is to use the \gls{ef} command line tools to directly migrate the database using the command \lstcode{dotnet ef database update}. This is usually the preferred method, but may not be feasible depending on the setup of the database. When direct migration is not possible, the \gls{ef} command line tools can also be used to create a \gls{sql} script. This is achieved using the command \lstcode{dotnet ef migrations script}. Both methods offer the option to revert the database by specifying the \lstcode{From} and \lstcode{To} migrations explicitly.

One limitation of the SQLite database engine is that a table or column cannot be dropped once it has been created. Therefore, the Jukebox project only contains one migration. This limitation prevents a series of migrations which include drop operations. The practical solution to this problem is to create a new database each time a migration would occur. This is not problematic as long as an application is under development, but as soon as it is used productively, a migration strategy will have to be developed separately.

\file{migration.cs}{Excerpt of a migration class.}{NC_CSharp}

\Section{Architecture}

Modularity is a key aspect when developing any application. In \gls{asp}, modularity can be gained by several methods, one of which are middlewares, as discussed in \myref{subsubsec:owin}. Although using middlewares is a good start, there are many other parts of an application which can be modularized, for example separating database code, business logic, and validation logic from each other.

\Subsubsection{Project structure}

The back-end C\# Solution, shown in \myautoref{fig:projectStructure.png}, contains six different projects. They are classified as database projects, framework projects, acceptance tests, and the \gls{asp} project.

The database projects contain one project with specific SQLite database classes and another one with in-memory database helper classes. Both projects contain neither domain classes nor the abstract data context because those classes are used by all databases and should therefore be located in a separate project. Using a separate project for database engine specific classes makes it easy to support another engine later on. This is due to the fact that a migration is engine-specific and the \gls{ef} command line tools do not support multiple engines in one project. It is possible to use a single set of migrations for different database engines, but it requires the developer to write the migrations on his own.

The framework solution folder contains the \lstcode{Jukebox.Common} and \lstcode{Jukebox\allowbreak .Common\allowbreak .Abstractions} projects. All interfaces for business and validation logic classes are part of the \lstcode{Jukebox.Common.Abstractions} project. Furthermore, the domain classes and the abstract data context are part of this \gls{dll}. All business and validation implementations are contained in the \lstcode{Jukebox\allowbreak .Common} project. This separation makes it possible to swap implementations without breaking too many dependencies.

Every good application should be tested to a certain degree to ensure that it works correctly. The Jukebox project does not contain many tests, because it is a proof-of-concept application. However, acceptance tests are easy to write and maintain, and thus provide an economic compromise between development time and quality.

Finally, the \lstcode{JukeboxAPI} project contains the \gls{asp} specific code, like controller classes and the \lstcode{Startup} and \lstcode{Program} classes. This is the only project which references any \gls{asp} specific \glspl{dll}.

\image[scale=.8]{projectStructure.png}{C\# project structure.}

\Subsubsection{Services and Validation}

Another step towards a modularized application is the use of a service layer. The service layer handles all the business logic the application needs to function. An example for this is the \lstcode{IPlayerService}, shown in \myautoref{lst:IPlayerService.cs}. This service contains methods for creating a \lstcode{Player} object, adding a song to a \lstcode{Player} object, executing a command on a certain player, or getting details about one specific or all players available.

For each domain there is one service class. These services are accessed through constructor injection and are used in controllers as well as other services. Each service and all of the controllers use the \gls{tpl} and the C\# Async and Await pattern \cite{tpl}. This pattern simplifies asynchronous programming provided that the programmer abides by certain rules. Once the developer chooses to use the Async and Await pattern, every method should return a \lstcode{Task} object which in consequence means that no part of the application should use a synchronous programming model anymore. A \lstcode{Task} should never be awaited using the \lstcode{Result} property or \lstcode{Wait()} method, because these may cause deadlocks. Instead, the \lstcode{await} keyword should be used.

\file{IPlayerService.cs}{The \lstcode{IPlayerService} interface.}{NC_CSharp}

Validation is an important aspect of any application. The back-end has to verify that the data sent by a client is structurally and semantically correct and that the client is authorized to execute the action. This is done by interception in the Jukebox project. Each service has an associated interceptor as well as an associated validator class. The interceptor decides which aspects of a method have to be validated and the validator class contains the logic for the validation. This separation is necessary because the interceptor is tightly coupled to the service it is intercepting, while the validator should only be concerned with the object it is supposed to validate. The \lstcode{IPlayerService} interface contains a method called \lstcode{AddSongToPlayerAsync()} (\myautoref{lst:IPlayerService.cs}). This method will be intercepted and the interceptor has to validate that both the player and the song with the given ID do exist. For this purpose the interceptor holds a reference to the \lstcode{PlayerValidator} and the \lstcode{SongValidator} objects which contain the needed methods for validation, as shown in \myautoref{lst:addSongToPlayerAsync.cs}. If the validation methods were to reside within the interceptor, this scenario would not be possible.

\file{addSongToPlayerAsync.cs}{Intercepting the \lstcode{AddSongToPlayerAsync} method.}{NC_CSharp}

\Section{ASP.NET Core Websockets}

To use websockets in \gls{asp}, the websocket middleware must be added to the middleware pipeline. Here, the developer can configure settings like the \lstcode{KeepAliveInterval} and the \lstcode{ReceiveBufferSize}. Whether a request is a request for a websocket or not, can be detected using the \lstcode{IsWebSocketRequest} property on the \lstcode{HttpContext.WebSockets} object. When such a request is detected, the communication can be established using the \lstcode{AcceptWebSocket\-Async()} method on the \lstcode{HttpContext.WebSocket} object. This method returns a \lstcode{Task<WebSocket>} of which the \lstcode{WebSocket} is used for the entire communication. \cite{aspWebsockets}

After accepting the socket, the Jukebox \gls{asp} server will authenticate the client and, if the authentication was successful, create a \lstcode{Player} object. Since the websocket connection will be terminated once the request is finished, the server will use a \enquote{keep-alive loop}, as shown in \myautoref{lst:HandlePlayerOwnerWebsocket.cs}. This loop will wait for any message coming from the player. Once a message arrives, the server checks whether the client wants to terminate the session or has sent data. In case of termination, the websocket will be closed and the \lstcode{Player} object will be destroyed. If the client has sent data, the server will handle the message in its \lstcode{HandlePlayerMessage()} method.

\newpage

\file{HandlePlayerOwnerWebsocket.cs}{The \enquote{keep-alive loop} for a websocket.}{NC_CSharp}
