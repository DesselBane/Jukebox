% !TEX root=../report.tex

\Chapter{ASP.NET Core}

\revMark{TBD}

\Section{ASP.NET Core Basics}

\gls{asp} is a cross-platform, open-source framework for building cloud- and web-based applications. It is the latest of Microsoft's web frameworks. Although the name is very similar to the ASP.NET framework, \gls{asp} is not its 5th version, but a new framework rewritten from the ground up. It combines the previously independent ASP.NET MVC and ASP.NET Web API frameworks into one single programming model. It uses the new .NET Core framework which is platform-independent, but projects may also target the Windows-only .NET framework. \cite{introASP}

\Subsubsection{NuGet}

The \gls{asp} framework relies on the NuGet Package Manager for its modularity. The NuGet Package Manager is very similar to Node's \gls{npm}. The packages to be used in a project can either be configured using the command line, or directly editing the *.csproj file, or using the \gls{gui} tools most .NET Core \gls{ide}s provide. This makes it possible to download the necessary parts of the \gls{asp} framework only. Microsoft also allows third parties to publish libraries on its NuGet platform. This was also done in the Jukebox project for some of the middlewares.

\Subsubsection{OWIN}

\gls{owin} is another big aspect of \gls{asp}'s modularity. \gls{owin} is not a specific implementation, but rather a specification which helps developers to create a modular architecture and was used to create the \gls{asp} framework. Katana is the codename Microsoft gave its \gls{owin} implementation and should not be confused with \gls{owin} itself.

The most important concept for a developer is that of a middleware. In the \gls{owin} specification, a middleware is defined as an exchangeable programming block with the following signature: \lstcode{Func<IDictionary<string, object>, Task>}. This means a middleware is a delegate which is given an \lstcode{IDictionary} object containing key-value-pairs and which has to return a \lstcode{Task} object. By using a \lstcode{Task}, Microsoft enables programmers to take advantage of the \gls{tpl} and its asynchronous programming model \cite{tpl}.

Middlewares are usually provided by the \gls{asp} framework, or they can be created by the developer for specific tasks. In order to create a middleware the developer has two options. He may simply create a delegate with the correct signature. Since this is similar to functional programming, Microsoft also provided a method to use classes. When a class is used, the \gls{asp} framework will check whether this class contains a method which matches the signature of a middleware. Using this method, the developer may take advantage of \gls{di} for any dependencies the custom middleware requires. \cite{owinKatana}

Another concept defined by the \gls{owin} standard is the middleware pipeline. Every \gls{http} request will traverse this pipeline and be processed along the way. A request is often refered to as context and is contained in the \lstcode{IDictionary} object of the middleware delegate. Depending on the circumstances, a middleware might alter the request and call the next middleware, or complete the request. Each request starts at the first middleware. Yet not every request reaches the last middleware, since it might be processed before it gets to the end. Once a request is processed, it travels back to the beginning of the pipeline. This is illustrated in \myautoref{fig:owin-middleware-chain.png}.

\autoImg{owin-middleware-chain.png}{Example of an OWIN middleware pipeline. \cite{owinKatana}}

\Subsubsection{The \lstcode{Program} class}

Like any other C\# project, an \gls{asp} project is rooted in the \lstcode{Program} class and its \lstcode{Main()} method. As of .NET Core 2.x, the code required to start a \lstcode{WebHost} has been simplified, as shown in \myautoref{lst:main.cs} \cite{aspFundamentals}. In the Jukebox project, the \gls{url} was explicitly defined. It is still possible to configure options like the \gls{iis} integration, a custom content root path, and many more through the \lstcode{WebHostBuilder} class. Any configuration through the \lstcode{WebHostBuilder} will overwrite the configuration done via the launchSettings.json file.

\file{main.cs}{The \lstcode{Main()} method of the Jukebox project.}{NC_CSharp}

The underlying web server of \gls{asp} is called Kestrel. It is a minimalistic web server which only provides three features. Those are HTTPS, Websockets, and Unix sockets for high performance behind Nginx. Kestrel should never be used as a standalone solution, but rather in combination with another web server like \gls{iis}, Nginx or Apache \cite{kestrel}.

\Subsubsection{The \lstcode{Startup} class}

The \lstcode{Startup} class is used to configure an \gls{asp} application. It is separated into two methods: the \lstcode{ConfigureServices()} and the \lstcode{Configure()} method. This class is called \lstcode{Startup} by convention, but may be named differently. If a another name is choosen, the developer has to specify it via the \lstcode{WebHostBuilder.UseStartup<T>()} method as shown in \myautoref{lst:main.cs}. The \lstcode{Startup} class does not implement any interfaces. The \gls{asp} framework detects the required methods via reflection. This is necessary since these methods have multiple applicable signatures, which are handled differently by the framework.

\gls{di} is an integral part of the \gls{asp} framework and is configured in the \lstcode{ConfigureServices()} method. This method has one parameter of type \lstcode{IServiceCollection} which is an interface similar to the \revMark{AutoFac} \lstcode{ConatinerBuilder} class. In order to make classes and framework parts available, such as the \gls{mvc} functionality of \gls{asp}, they have to be registered using this interface.

The \lstcode{IServiceCollection} interface provides many features which are sufficient for most projects, but it is not possible to configure interception using this interface. If the developer needs or wants to use interception, he has to change the signature of the \lstcode{ConfigureServices()} method to return an \lstcode{IServiceProvider} interface. This interface is Microsoft's abstraction of a \lstcode{Container} class which is used to resolve dependencies. In the Jukebox project, the AutoFac \gls{di} framework was used, because it supports all of \gls{asp}'s \gls{di} interfaces \cite{autofacCoreDoc}. It should be noted that it is also possible to use other \gls{di} frameworks, but custom adapters may have to be implemented \cite{aspCustomDI}.

The Jukebox project uses a dual approach. \gls{asp} components are registered via the \lstcode{IServiceCollection} interface because extension methods are provided by the framework. All other classes were registered using the \lstcode{ContainerBuilder} class to enable interception. Then all registrations from the \lstcode{IServiceCollection} interface are transferred to the \lstcode{ContainerBuilder} using the \lstcode{Populate()} method. Finally, a \lstcode{IServiceProvider} is created using the  \lstcode{AutofacServiceProvider} class. This is illustrated in \myautoref{lst:configureJukebox.cs}.

\file{configureJukebox.cs}{Configuring the \lstcode{IServiceCollection} in combination with an AutoFac \lstcode{ContainerBuilder}.}{NC_CSharp}

Once all components are registered, the \gls{asp} framework calls the \lstcode{Configure()} method. This method is used to build the \gls{owin} middleware pipeline. Its first argument is of type \lstcode{IApplicationBuilder} and is required. The second and third arguments are of type \lstcode{IHostingEnvironment} and \lstcode{ILoggerFactory}, respectively, and are optional.

The \lstcode{IApplicationBuilder} interface is used to set up the pipeline, as shown in \myautoref{lst:configure.cs}. \gls{asp} provides extension methods for all of the framework's middlewares. There are multiple options to register a custom middleware. The \lstcode{IApplicationBuilder.Run()} method can be used to specify a delegate which will run and terminate the pipeline at this point. In order to chain middlewares the \lstcode{IApplicationBuilder.Use()} method can be used. This method also takes a middleware delegate as parameter. The \lstcode{IApplicationBuilder.UseMiddleware<T>()} method is used for middlewares which are written as a class. \cite{aspMiddleware}

It is important to bear in mind that the middleware, which is registered first, will always be called first by the framework for each request that is processed. This means that the authentication middleware should always be registered before the \gls{mvc} middleware, otherwise requests might not be authenticated properly. In the Jukebox project, the \lstcode{ExceptionMiddleware} is registered first since it is supposed to catch any exception thrown in the pipeline later on. Next, the \lstcode{Swagger} and \lstcode{SpaMiddleware} are added because they do not require authentication. These are followed by the \lstcode{Authentication}, \gls{mvc}, and \lstcode{WebSocket} middlewares. Finally, the \lstcode{StaticFiles} middleware is added.

\file{configure.cs}{Building the OWIN middleware pipeline.}{NC_CSharp}

\Section{ASP.NET MVC Core}


Middlewares are a great concept, but developing an entire application on the basis of just middlewares is very tedious. Instead \gls{asp} offers the \gls{mvc} middleware. This pre-built middleware allows the developer to write his code in seperate independent classes which know nothing about \gls{owin} or the concept of a middleware. This, as the name suggest, follows the \gls{mvc} pattern. To use the \gls{mvc} package it has to be registered with the \gls{di} container, as shown in \myautoref{lst:configureMvc.cs}.

\gls{mvc} is a popular pattern in software development and consist of three main components: Model, View, and Controller (\myautoref{fig:mvc.png}). The model represents the state of the application and any buisiness logic or operations needed. All visuals and any logic to manipulate these are the View. In the \gls{asp} context the Razor view engine is used to embed .NET code in the \gls{html}. This allows for easily manipulating the view. The controller is responsible for handling user interactions. It deceides which view to render and which methods to call to manipulate the model. In case of the Jukebox project, the view part was not used since all view related actions take place inside the Angular code. \cite{mvcOverview}

\image[scale=.5]{mvc.png}{The three main components of the MVC pattern. \cite{mvcOverview}}

\Subsubsection{Jukebox MVC configuration}

The \lstcode{AddMvc()} extension method offers the posibillity to configure the \gls{mvc} middleware. In the Jukebox project configurations for authorization handling and controller registration were made.

The \gls{mvc} package offers many ways to protect certain routes or actions. A developer may choose between filters and attributes or accept the defaults. It is important to note that the \gls{mvc} package is not authenticating or authorizing any request by itself. For this part a special middleware is used. \gls{mvc} only checks the \lstcode{HttpContext} for information about if and how a request is authorized and acts accordingly. The default is that every route is unprotected. In many cases certain actions should only be executed if the request is authorized. There are two common solutions to this problem. First, a blacklist approach where every route is accessible and only some are protected explicitly. In this case the developer uses the \lstcode{Authorize} attribute on any controller method which should be protected. The second method is to use a whitelist approach where every route is protected and the unprotected routes are specified explicitly. This approach is used in the Jukebox project. As shown in \myautoref{lst:configureMvc.cs}, a filter is created using the \lstcode{AuthorizationPolicyBuilder} class and applied to all routes. Then any route which is supposed to be accessible without authorization is marked with the \lstcode{[AllowAnonymous]} attribute.

The \lstcode{AddControllersAsServices()} (\mylineref{lst:configureMvc.cs}{confMvc_controller}) configuration option forces the developer to register all controller classes explicitly. This has the advantage of registering all controllers with a custom container and was used to register all controllers with an interceptor that checks for invalid data passed in a request.

\file{configureMvc.cs}{Registering the MVC package.}{NC_CSharp}


\Subsubsection[mappingUrls]{Mapping URLs}

Mapping of a \gls{url} to a controller action works by convention or explicit configuration. If nothing is specified the convention is to map a \gls{url} to the controller's name followed by the method's name. For example the \enquote{/Home/Authors} \gls{url} maps to the \lstcode{HomeController} and its \lstcode{Authors()} method. Custom conventions may be specified when adding the \gls{mvc} middleware to the middleware pipeline. As shown in \myautoref{lst:mapRoute.cs}, a default route which mapps to the \lstcode{HomeController} and its \lstcode{Index()} method is created.

\file{mapRoute.cs}{A custom route mapping convention. \cite{routeConvention}}{NC_CSharp}

Another way of explicitly configurating mappings are Attributes. For a controller there exists the \lstcode{[Route]} attribute. This was used in the Jukebox project since all controllers are supposed to be part of the \enquote{api/} route. The \lstcode{[Route]} attribute also offers macros. This allows the developer to use the same attribute for all controllers, namely: \lstcode{[Route("api/[controller]/[action]")]}. The \lstcode{[controller]} macro tells the framework to use the name of the controller which is decorated by this attribute. Similarly the \lstcode{[action]} macro specifies to use the name of the method or its custom specified route.

For methods, also called actions, there are several attributes which are derived from the abstract \lstcode{HttpMethodAttribute} class. These include \lstcode{[HttpPost]}, \lstcode{[HttpGet]}, and more, one for every \gls{http} verb. Their main purpose is to specify the \gls{http} verb but they also include a template option to configure the \gls{mvc} mapping. This is needed if two \gls{url}s only differ in their verbs to deceide which method on the controller should be called. Also many \gls{rest} \gls{api}s use integers in the \gls{url} to reference business objects by their ID. This is supported through the curly brackets notation. An example of this would be if the \lstcode{Player} object with ID 11 should do something a \gls{url} like \enquote{/api/player/11/doSomething} could be mapped with the \lstcode{[HttpPost("\{playerId\}/doSomething")]} attribute.

\Subsubsection{Transfering Data}

Especially in case of a web \gls{api} transfering data is very important. The most common options to transfer data via a \gls{http} request are sending the data in the \gls{http} body, embedding the data into the \gls{url} using a query string, or inserting IDs into the \gls{url} as described in \myref{subsubsec:mappingUrls}. For small bits of information like a \lstcode{string} or \lstcode{int} the query string method should be used. To tell \gls{asp} that a method argument should be mapped to a query string argument the \lstcode{[FromQuery]} attribute is used, as shown in \mylineref{lst:dataTransfer.cs}{dataT_query}.

In case of one or many objects which need to be transferred the \gls{http} body should be used. This is done via the \lstcode{[FromBody]} attribute, as shown in \mylineref{lst:dataTransfer.cs}{dataT_body}. The transfered data is usually in form of a \gls{json} string although it is also possible to use \gls{xml}. \gls{asp} automatically tries to parse the \gls{json} string into an object of the specified type, in this example an object of type \lstcode{PlayerCommand}.

For the Jukebox project many classes like the \lstcode{PlayerCommand} were written. These classes are refered to as \gls{dto} and are usually \lstcode{sealed} classes which only contain properties as well as different contructors. Each \gls{dto} is annotated with the \lstcode{[DataContract]} attribute and every property which is intended to be serealized is annotated with the \lstcode{[DataMemeber]} attribute. Some properties are used to convert data from one type to another and are therefore not annotated with the \lstcode{[DataMember]} attribute, which causes the framework to ignore them during the serialization. This works well for most data types, the only exception are enums. Enums are by default serialized as integers since in C\# the integer is the underlying type of a default enum. This default behavior can be changed with the \lstcode{[JsonConverter(typeof(StringEnumConverter))]} attribute to serialize enums as a string which improves readability on the frontend part and helps compatability with the \gls{ts} implementation of an enum.

\file{dataTransfer.cs}{Different data transfer methods in ASP.NET Core.}{NC_CSharp}














\Subsubsection{JWT Bearer Token}

\Section{Custom Middlewares}

\Section{ASP.NET Core Websockets}

\Section{Remember these points}
