% !TEX root=../report.tex

\Chapter{ASP.NET Core}

\revMark{TBD}

\Section{ASP.NET Core Basics}

\gls{asp} is a cross-platform, open-source framework for building cloud- and web-based applications. It is the latest of Microsoft's web frameworks. Although the name is very similar to the ASP.NET framework, \gls{asp} is not its 5th version, but a new framework rewritten from the ground up. It combines the previously independent ASP.NET MVC and ASP.NET Web API frameworks into one single programming model. It uses the new .NET Core framework which is platform-independent, but projects may also target the Windows-only .NET framework. \cite{introASP}

\Subsubsection{NuGet}

The \gls{asp} framework relies on the NuGet Package Manager for its modularity. The NuGet Package Manager is very similar to Node's \gls{npm}. The packages to be used in a project can either be configured using the command line, or directly editing the *.csproj file, or using the \gls{gui} tools most .NET Core \gls{ide}s provide. This makes it possible to download the necessary parts of the \gls{asp} framework only. Microsoft also allows third parties to publish libraries on its NuGet platform. This was also done in the Jukebox project for some of the middlewares.

\Subsubsection{OWIN}

\gls{owin} is another big aspect of \gls{asp}'s modularity. \gls{owin} is not a specific implementation, but rather a specification which helps developers to create a modular architecture and was used to create the \gls{asp} framework. Katana is the codename Microsoft gave its \gls{owin} implementation and should not be confused with \gls{owin} itself.

The most important concept for a developer is that of a middleware. In the \gls{owin} specification, a middleware is defined as an exchangeable programming block with the following signature: \lstcode{Func<IDictionary<string, object>, Task>}. This means a middleware is a delegate which is given an \lstcode{IDictionary} object containing key-value-pairs and which has to return a \lstcode{Task} object. By using a \lstcode{Task}, Microsoft enables programmers to take advantage of the \gls{tpl} and its asynchronous programming model \cite{tpl}.

Middlewares are usually provided by the \gls{asp} framework, or they can be created by the developer for specific tasks. In order to create a middleware the developer has two options. He may simply create a delegate with the correct signature. Since this is similar to functional programming, Microsoft also provided a method to use classes. When a class is used, the \gls{asp} framework will check whether this class contains a method which matches the signature of a middleware. Using this method, the developer may take advantage of \gls{di} for any dependencies the custom middleware requires. \cite{owinKatana}

Another concept defined by the \gls{owin} standard is the middleware pipeline. Every \gls{http} request will traverse this pipeline and be processed along the way. A request is often refered to as context and is contained in the \lstcode{IDictionary} object of the middleware delegate. Depending on the circumstances, a middleware might alter the request and call the next middleware, or complete the request. Each request starts at the first middleware. Yet not every request reaches the last middleware, since it might be processed before it gets to the end. Once a request is processed, it travels back to the beginning of the pipeline. This is illustrated in \myautoref{fig:owin-middleware-chain.png}.

\autoImg{owin-middleware-chain.png}{Example of an OWIN middleware pipeline. \cite{owinKatana}}

\Subsubsection{The \lstcode{Program} class}

Like any other C\# project, an \gls{asp} project is rooted in the \lstcode{Program} class and its \lstcode{Main()} method. As of .NET Core 2.x, the code required to start a \lstcode{WebHost} has been simplified, as shown in \myautoref{lst:main.cs} \cite{aspFundamentals}. In the Jukebox project, the \gls{url} was explicitly defined. It is still possible to configure options like the \gls{iis} integration, a custom content root path, and many more through the \lstcode{WebHostBuilder} class. Any configuration through the \lstcode{WebHostBuilder} will overwrite the configuration done via the launchSettings.json file.

\file{main.cs}{The \lstcode{Main()} method of the Jukebox project.}{NC_CSharp}

The underlying web server of \gls{asp} is called Kestrel. It is a minimalistic web server which only provides three features. Those are HTTPS, Websockets, and Unix sockets for high performance behind Nginx. Kestrel should never be used as a standalone solution, but rather in combination with another web server like \gls{iis}, Nginx or Apache \cite{kestrel}.

\Subsubsection{The \lstcode{Startup} class}

The \lstcode{Startup} class is used to configure an \gls{asp} application. It is separated into two methods: the \lstcode{ConfigureServices()} and the \lstcode{Configure()} method. This class is called \lstcode{Startup} by convention, but may be named differently. If a another name is choosen, the developer has to specify it via the \lstcode{WebHostBuilder.UseStartup<T>()} method as shown in \myautoref{lst:main.cs}. The \lstcode{Startup} class does not implement any interfaces. The \gls{asp} framework detects the required methods via reflection. This is necessary since these methods have multiple applicable signatures, which are handled differently by the framework.

\gls{di} is an integral part of the \gls{asp} framework and is configured in the \lstcode{ConfigureServices()} method. This method has one parameter of type \lstcode{IServiceCollection} which is an interface similar to the \revMark{AutoFac} \lstcode{ConatinerBuilder} class. In order to make classes and framework parts available, such as the \gls{mvc} functionality of \gls{asp}, they have to be registered using this interface.

The \lstcode{IServiceCollection} interface provides many features which are sufficient for most projects, but it is not possible to configure interception using this interface. If the developer needs or wants to use interception, he has to change the signature of the \lstcode{ConfigureServices()} method to return an \lstcode{IServiceProvider} interface. This interface is Microsoft's abstraction of a \lstcode{Container} class which is used to resolve dependencies. In the Jukebox project, the AutoFac \gls{di} framework was used, because it supports all of \gls{asp}'s \gls{di} interfaces \cite{autofacCoreDoc}. It should be noted that it is also possible to use other \gls{di} frameworks, but custom adapters may have to be implemented \cite{aspCustomDI}.

The Jukebox project uses a dual approach. \gls{asp} components are registered via the \lstcode{IServiceCollection} interface because extension methods are provided by the framework. All other classes were registered using the \lstcode{ContainerBuilder} class to enable interception. Then all registrations from the \lstcode{IServiceCollection} interface are transferred to the \lstcode{ContainerBuilder} using the \lstcode{Populate()} method. Finally, a \lstcode{IServiceProvider} is created using the  \lstcode{AutofacServiceProvider} class. This is illustrated in \myautoref{lst:configureJukebox.cs}.

\file{configureJukebox.cs}{Configuring the \lstcode{IServiceCollection} in combination with an AutoFac \lstcode{ContainerBuilder}.}{NC_CSharp}

Once all components are registered, the \gls{asp} framework calls the \lstcode{Configure()} method. This method is used to build the \gls{owin} middleware pipeline. Its first argument is of type \lstcode{IApplicationBuilder} and is required. The second and third arguments are of type \lstcode{IHostingEnvironment} and \lstcode{ILoggerFactory}, respectively, and are optional.

The \lstcode{IApplicationBuilder} interface is used to set up the pipeline, as shown in \myautoref{lst:configure.cs}. \gls{asp} provides extension methods for all of the framework's middlewares. There are multiple options to register a custom middleware. The \lstcode{IApplicationBuilder.Run()} method can be used to specify a delegate which will run and terminate the pipeline at this point. In order to chain middlewares the \lstcode{IApplicationBuilder.Use()} method can be used. This method also takes a middleware delegate as parameter. The \lstcode{IApplicationBuilder.UseMiddleware<T>()} method is used for middlewares which are written as a class. \cite{aspMiddleware}

It is important to bear in mind that the middleware, which is registered first, will always be called first by the framework for each request that is processed. This means that the authentication middleware should always be registered before the \gls{mvc} middleware, otherwise requests might not be authenticated properly. In the Jukebox project, the \lstcode{ExceptionMiddleware} is registered first since it is supposed to catch any exception thrown in the pipeline later on. Next, the \lstcode{Swagger} and \lstcode{SpaMiddleware} are added because they do not require authentication. These are followed by the \lstcode{Authentication}, \gls{mvc}, and \lstcode{WebSocket} middlewares. Finally, the \lstcode{StaticFiles} middleware is added.

\file{configure.cs}{Building the OWIN middleware pipeline.}{NC_CSharp}

\Section{ASP.NET Core Websockets}

\Section{Remember these points}
