% !TEX root=../report.tex

\Chapter{ASP.NET Core}

\revMark{TBD}

\Section{ASP.NET Core Basics}

\gls{asp} is a cross-platform, open-source framework for building cloud- and web-based applications. It is the latest of Microsoft's web frameworks. Although the name is very similar to the ASP.NET framework, \gls{asp} is not its 5th version, but a new framework rewritten from the ground up. It combines the previously independent ASP.NET MVC and ASP.NET Web API frameworks into one single programming model. It uses the new .NET Core framework which is platform-independent, but projects may also target the Windows-only .NET framework. \cite{introASP}

\Subsubsection{NuGet}

The \gls{asp} framework relies on the NuGet Package Manager for its modularity. The NuGet Package Manager is very similar to Node's \gls{npm}. The packages to be used in a project can either be configured using the command line, or directly editing the *.csproj file, or using the \gls{gui} tools most .NET Core \gls{ide}s provide. This makes it possible to download the necessary parts of the \gls{asp} framework only. Microsoft also allows third parties to publish libraries on its NuGet platform. This was also done in the Jukebox project for some of the middlewares.

\Subsubsection{OWIN}

\gls{owin} is another big aspect of \gls{asp}'s modularity. \gls{owin} is not a specific implementation, but rather a specification which helps developers to create a modular architecture and was used to create the \gls{asp} framework. Katana is the codename Microsoft gave its \gls{owin} implementation and should not be confused with \gls{owin} itself.

The most important concept for a developer is that of a middleware. In the \gls{owin} specification, a middleware is defined as an exchangeable programming block with the following signature: \lstcode{Func<IDictionary<string, object>, Task>}. This means a middleware is a delegate which is given an \lstcode{IDictionary} object containing key-value-pairs and which has to return a \lstcode{Task} object. By using a \lstcode{Task}, Microsoft enables programmers to take advantage of the \gls{tpl} and its asynchronous programming model \cite{tpl}.

Middlewares are usually provided by the \gls{asp} framework, or they can be created by the developer for specific tasks. In order to create a middleware the developer has two options. He may simply create a delegate with the correct signature. Since this is similar to functional programming, Microsoft also provided a method to use classes. When a class is used, the \gls{asp} framework will check whether this class contains a method which matches the signature of a middleware. Using this method, the developer may take advantage of \gls{di} for any dependencies the custom middleware requires. \cite{owinKatana}

Another concept defined by the \gls{owin} standard is the middleware pipeline. Every \gls{http} request will traverse this pipeline and be processed along the way. A request is often refered to as context and is contained in the \lstcode{IDictionary} object of the middleware delegate. Depending on the circumstances, a middleware might alter the request and call the next middleware, or complete the request. Each request starts at the first middleware. Yet not every request reaches the last middleware, since it might be processed before it gets to the end. Once a request is processed, it travels back to the beginning of the pipeline. This is illustrated in \myautoref{fig:owin-middleware-chain.png}.

\autoImg{owin-middleware-chain.png}{Example of an OWIN middleware pipeline. \cite{owinKatana}}

\Subsubsection{The \lstcode{Program} class}

Like any other C\# project, an \gls{asp} project is rooted in the \lstcode{Program} class and its \lstcode{Main()} method. As of .NET Core 2.x, the code required to start a \lstcode{WebHost} has been simplified, as shown in \myautoref{lst:main.cs} \cite{aspFundamentals}. In the Jukebox project, the \gls{url} was explicitly defined. It is still possible to configure options like the \gls{iis} integration, a custom content root path, and many more through the \lstcode{WebHostBuilder} class. Any configuration through the \lstcode{WebHostBuilder} will overwrite the configuration done via the launchSettings.json file.

\file{main.cs}{The \lstcode{Main()} method of the Jukebox project.}{NC_CSharp}

The underlying web server of \gls{asp} is called Kestrel. It is a minimalistic web server which only provides three features. Those are HTTPS, Websockets, and Unix sockets for high performance behind Nginx. Kestrel should never be used as a standalone solution, but rather in combination with another web server like \gls{iis}, Nginx or Apache \cite{kestrel}.

\Subsubsection{The \lstcode{Startup} class}

The \lstcode{Startup} class is used to configure an \gls{asp} application. It is separated into two methods: the \lstcode{ConfigureServices()} and the \lstcode{Configure()} method. This class is called \lstcode{Startup} by convention, but may be named differently. If a another name is choosen, the developer has to specify it via the \lstcode{WebHostBuilder.UseStartup<T>()} method as shown in \myautoref{lst:main.cs}. The \lstcode{Startup} class does not implement any interfaces. The \gls{asp} framework detects the required methods via reflection. This is necessary since these methods have multiple applicable signatures, which are handled differently by the framework.

\gls{di} is an integral part of the \gls{asp} framework and is configured in the \lstcode{ConfigureServices()} method. This method has one parameter of type \lstcode{IServiceCollection} which is an interface similar to the \revMark{AutoFac} \lstcode{ConatinerBuilder} class. In order to make classes and framework parts available, such as the \gls{mvc} functionality of \gls{asp}, they have to be registered using this interface.

The \lstcode{IServiceCollection} interface provides many features which are sufficient for most projects, but it is not possible to configure interception using this interface. If the developer needs or wants to use interception, he has to change the signature of the \lstcode{ConfigureServices()} method to return an \lstcode{IServiceProvider} interface. This interface is Microsoft's abstraction of a \lstcode{Container} class which is used to resolve dependencies. In the Jukebox project, the AutoFac \gls{di} framework was used, because it supports all of \gls{asp}'s \gls{di} interfaces \cite{autofacCoreDoc}. It should be noted that it is also possible to use other \gls{di} frameworks, but custom adapters may have to be implemented \cite{aspCustomDI}.

The Jukebox project uses a dual approach. \gls{asp} components are registered via the \lstcode{IServiceCollection} interface because extension methods are provided by the framework. All other classes were registered using the \lstcode{ContainerBuilder} class to enable interception. Then all registrations from the \lstcode{IServiceCollection} interface are transferred to the \lstcode{ContainerBuilder} using the \lstcode{Populate()} method. Finally, a \lstcode{IServiceProvider} is created using the  \lstcode{AutofacServiceProvider} class. This is illustrated in \myautoref{lst:configureJukebox.cs}.

\file{configureJukebox.cs}{Configuring the \lstcode{IServiceCollection} in combination with an AutoFac \lstcode{ContainerBuilder}.}{NC_CSharp}

Once all components are registered, the \gls{asp} framework calls the \lstcode{Configure()} method. This method is used to build the \gls{owin} middleware pipeline. Its first argument is of type \lstcode{IApplicationBuilder} and is required. The second and third arguments are of type \lstcode{IHostingEnvironment} and \lstcode{ILoggerFactory}, respectively, and are optional.

The \lstcode{IApplicationBuilder} interface is used to set up the pipeline, as shown in \myautoref{lst:configure.cs}. \gls{asp} provides extension methods for all of the framework's middlewares. There are multiple options to register a custom middleware. The \lstcode{IApplicationBuilder.Run()} method can be used to specify a delegate which will run and terminate the pipeline at this point. In order to chain middlewares the \lstcode{IApplicationBuilder.Use()} method can be used. This method also takes a middleware delegate as parameter. The \lstcode{IApplicationBuilder.UseMiddleware<T>()} method is used for middlewares which are written as a class. \cite{aspMiddleware}

It is important to bear in mind that the middleware, which is registered first, will always be called first by the framework for each request that is processed. This means that the authentication middleware should always be registered before the \gls{mvc} middleware, otherwise requests might not be authenticated properly. In the Jukebox project, the \lstcode{ExceptionMiddleware} is registered first since it is supposed to catch any exception thrown in the pipeline later on. Next, the \lstcode{Swagger} and \lstcode{SpaMiddleware} are added because they do not require authentication. These are followed by the \lstcode{Authentication}, \gls{mvc}, and \lstcode{WebSocket} middlewares. Finally, the \lstcode{StaticFiles} middleware is added.

\file{configure.cs}{Building the OWIN middleware pipeline.}{NC_CSharp}

\Section{ASP.NET MVC Core}


Middlewares are a great concept, but developing an entire application on the basis of just middlewares is very tedious. To make the development of web applications easier \gls{asp} offers the pre-built \gls{mvc} middleware. This middleware allows the developer to write his code in separate, independent classes which know nothing about \gls{owin} or the concept of a middleware. As the name suggests, using the \gls{mvc} middleware encourages the developer to implement his classes following the Model-View-Controller pattern. The \gls{mvc} package has to be registered with the \gls{di} container, as shown in \myautoref{lst:configureMvc.cs}.

\gls{mvc} is a popular pattern in software development and consists of three main components: Model, View, and Controller (\myautoref{fig:mvc.png}). The model represents the state of the application and any business logic or operations needed. All visual elements and any logic to manipulate these elements are considered the view. In the \gls{asp} context the Razor view engine is used to embed .NET code in \gls{html} markup. This allows for easy manipulation of the view. The controller is responsible for handling user interactions. It deceids which view to render, and which methods to call in order to manipulate the model. In case of the Jukebox project, the view part was not used since all view-related actions are located inside the Angular code. \cite{mvcOverview}

\image[scale=.5]{mvc.png}{The three main components of the MVC pattern. \cite{mvcOverview}}

\Subsubsection{Jukebox MVC configuration}

The \lstcode{AddMvc()} extension method offers the possibility to configure the \gls{mvc} middleware. In the Jukebox project, authorization handling and controller registration were configured explicitly.

To prevent unauthorized access, the \gls{mvc} package offers many ways to protect certain routes, also called actions. A developer may accept the default security settings or choose between filters and attributes to protect certain routes. It is important to note that the \gls{mvc} package does not authenticate or authorize any request at all. Another middleware is used specifically for this purpose. The \gls{jwt} Bearer middleware is the one used in the Jukebox project (see \myref{subsubsec:jwt}). \gls{mvc} only checks the \lstcode{HttpContext} to know whether and how a request is authorized, and then acts accordingly. By default, every route is unprotected. However, certain actions should only be executable if the request is authorized. There are two common solutions to this problem. First, a blacklist approach, where every route is accessible by default and the protected ones are declared explicitly. In this case, the developer uses the \lstcode{[Authorize]} attribute on any controller method which needs to be protected. The second option is to use a whitelist approach, where every route is protected by default and the unprotected routes are specified explicitly. As shown in \myautoref{lst:configureMvc.cs}, a filter is created using the \lstcode{AuthorizationPolicyBuilder} class and is applied to all routes. Then, all routes which shall be accessible without authorization are marked with the \lstcode{[AllowAnonymous]} attribute. The whitelist approach is used in the Jukebox project.

There are two ways of registering controllers for the \gls{mvc} package. By default, the \gls{mvc} package registers all classes with the \gls{di} container that are derived from the abstract \lstcode{Controller} base class and are located in the \enquote{Controllers} folder. If more functionality, such as interception, is needed the \lstcode{AddControllersAsServices()} configuration option can be used (\mylineref{lst:configureMvc.cs}{confMvc_controller}). This option forces the developer to register all controller classes explicitly. For the controllers registered in the Jukebox project, an interceptor is configured. This interceptor checks for null references passed to controller methods. If such a null reference is detected, the interceptor will throw a specific exception which results in a 400 \gls{http} response (see \myref{subsubsec:exceptionMiddleware}).

\file{configureMvc.cs}{Registering the MVC package.}{NC_CSharp}


\Subsubsection[mappingUrls]{Mapping URLs}

Mapping a \gls{url} to a controller action works either by convention or by explicit configuration. If nothing is specified, the convention is to map a \gls{url} to the controller's name followed by the method's name. For example the \enquote{/Home/Authors} \gls{url} is mapped to the \lstcode{HomeController} and its \lstcode{Authors()} method. Custom conventions may be specified when the \gls{mvc} middleware is added to the middleware pipeline. As shown in \myautoref{lst:mapRoute.cs}, a default route is created, which maps to the \lstcode{HomeController} and its \lstcode{Index()} method.

\file{mapRoute.cs}{A custom route mapping convention. \cite{routeConvention}}{NC_CSharp}

Attributes are another way of explicitly configuring mappings. The \lstcode{[Route]} attribute is used for controllers only. This attribute was used in the Jukebox project, since all controllers are supposed to be part of the \enquote{api/} route. The \lstcode{[Route]} attribute also offers macros. With macros it is possible to use the same attribute for all controllers: \lstcode{[Route("api/[controller]/[action]")]}. The \lstcode{[controller]} macro tells the framework to use the name of the controller which is decorated by the \lstcode{[Route]} attribute. Similarly, the \lstcode{[action]} macro references the name of the method or its custom-specified route.

For methods, also called actions, there are several attributes which are derived from the abstract \lstcode{HttpMethodAttribute} class. There is a matching attribute for each \gls{http} verb, \zB \lstcode{[HttpPost]}, \lstcode{[HttpGet]}, and so forth. Their main purpose is to specify the \gls{http} verb, in addition they include a template option to configure the \gls{mvc} mapping. This is neccessary to decide which method should be called on the controller if two \gls{url}s only differ in their \gls{http} verbs. A custom route is specified as a parameter in the \gls{http} verb attribute, \zB \lstcode{[HttpPost("my/custom/route")]}. Also, many \gls{rest} \gls{api}s use integers in the \gls{url} to reference a business object by its ID. This is supported through the curly bracket notation. A possible scenario is: some method should be executed on the \lstcode{Player} object with ID 11. This could be mapped to a \gls{url} like \enquote{/api/player/11/doSomething} and would result in an attribute such as \lstcode{[HttpPost("\{playerId\}/doSomething")]}. \cite{mvcRouting}



\Subsubsection{Transfering Data}

Especially in case of a web \gls{api}, the transfer of data is very important. The most common options to transfer data via a \gls{http} request are: sending the data in the \gls{http} body, embedding the data into the \gls{url} using a query string, or inserting IDs into the \gls{url} as described in \myref{subsubsec:mappingUrls}. For small bits of information like a \lstcode{string} or \lstcode{int}, the query string method is recommended. The \lstcode{[FromQuery]} attribute tells \gls{asp} that a method argument should be mapped to a query string argument, see \mylineref{lst:dataTransfer.cs}{dataT_query}. In this case the annotated argument's name must match the key in the query string.

For the transfer of objects or large amounts of data the \gls{http} body should be used. In this case the \lstcode{[FromBody]} attribute indicates that data from the \gls{http} body shall be parsed, as shown in \mylineref{lst:dataTransfer.cs}{dataT_body}. Usually, the data is transferred as a \gls{json} string, but it is also possible to use \gls{xml}. \gls{asp} automatically tries to parse the \gls{json} string into an object of the specified type, in this example an object of type \lstcode{PlayerCommand}.

\file{dataTransfer.cs}{Different data transfer methods in ASP.NET Core.}{NC_CSharp}

For the Jukebox project, many classes like the \lstcode{PlayerCommand} class were written. These classes are referred to as a \gls{dto} and are usually \lstcode{sealed} classes which only contain properties and constructors. Each \gls{dto} is annotated with the \lstcode{[DataContract]} attribute and every property to be serialized is annotated with the \lstcode{[DataMember]} attribute. Some properties are used to convert data from one type to another. These are not annotated with the \lstcode{[DataMember]} attribute and are therefore ignored during serialization. This works well for most data types, the only exception are enums. Enums are serialized as integers by default, because the integer is the underlying type of a default enum in C\#. The default behavior can be changed with the \lstcode{[JsonConverter(typeof(StringEnumConverter))]} attribute to serialize an enum as a string. This improves readability on the frontend part and provides compatibility for the \gls{ts} implementation of an enum. \cite{mvcModelBinding}

\Section{Security in ASP.NET Core}

Securing an application against data leaks and malicious activity is especially importent for a web application because it will be accessible by almost any person on this planet. In \gls{asp} the security aspect is split into two topics: authentication and authorization.

\Subsubsection{ASP.NET Core Authentication}

Authentication is the process where a client proves that he is the one he claims to be. Traditionally a client will provide a username and a password. The server will check them against a database and decide whether the client provided valid credentials or not. This basic form of authentication is still possible and is mostly referred to as \enquote{cookie authentication}. Its benefit is its simplicity but the drawback is its inflexibility. With the ASP.NET Core Identity package the developer can choose between a simple username-password-combination or an external login provider such as Facebook, Google, Microsoft Account, Twitter or others. This works by utilizing the OAuth 2.0 \cite{oauth2} or OpenID Connect \cite{openID} protocols.

\Subsubsection[jwt]{JWT Bearer Token Authentication}

\glslocalreset{jwt}

For the Jukebox project the \gls{jwt} Bearer authentication was choosen \cite{jwt}. \gls{jwt} is an open standard for securly transmitting information in a self-contained, compact \gls{json} object. The information is secured either using the symmetric \gls{hmac} algorithm \cite{hmac} or one of the asymmetric algorithms \gls{rsa} or \gls{ecdsa} \cite{ecdsa}. \gls{jwt} was choosen because it does not only yield a token a server uses to authenticate a client but also transmitts authorization information. This is especially important because the frontend can use this information to hide protected parts of the application a user is not authorized for.

Configuring the \gls{jwt} package is a multi-step procedure. First the \lstcode{TokenValidationParameters} have to be set (shown in \myautoref{lst:configureJwt.cs}). Then a \lstcode{JwtTokenOptions} object is configured (\myautoref{lst:configureJwtTokenOptions.cs}) and a method for creating a \gls{jwt} token is implemented (\myautoref{lst:generateBasicAuthToken.cs}). Finally the \gls{jwt} package is added to the middleware pipeline using the \lstcode{app.UseAuthentication()} extension method.

For the \lstcode{TokenValidationParameter} a \lstcode{SymmetricSecurityKey} object is created which must be identical to the key object which is later on used to validate a \gls{jwt} token. Then an \enquote{Issuer} and an \enquote{Audience} are set, both are optional. This is mainly for the purpose of identifying the application (issuer) and the client (audience). Finally, the option to validate the lifetime of a token is set to true and the clock skew is set to zero. \cite{jwtTokenAuth}

\file{configureJwt.cs}{Configuration of the JWT package.}{NC_CSharp}

The \lstcode{JwtTokenOptions} is an object written specifically for the Jukebox project which stores information needed to create new \gls{jwt} tokens. It consists of properties for the \enquote{Issuer} and \enquote{Audience}. Further there are properties which define the expiration timespan of the \gls{jwt} token itself as well as the expiration timespan of the refresh token. Finally, it contains the \lstcode{SigningCredentials} which constist of the key and an enum to determine which algorithm is used. As shown in \myautoref{lst:configureJwtTokenOptions.cs} the \gls{hmac} algorithm is used in the Jukebox project.

\file{configureJwtTokenOptions.cs}{Configuration of the \lstcode{JwtTokenOptions}.}{NC_CSharp}

The last step in setting up the \gls{jwt} authentication package is to create a method which issues a new token. This method is part of the \lstcode{JwtAuthenticationService} in the Jukebox project. A \lstcode{ClaimsIdentity} and a \lstcode{JwtTokenOptions} object are passed into the method. The \lstcode{ClaimsIdentity} is the C\# object to manage users when using a claims-based authorization system (described in \myref{subsubsec:claimsAuth}). First a list of claims is created. For this, the \gls{jwt} Subject \enquote{Sub}, \gls{jwt} ID \enquote{Jti}, and Issued At \enquote{Iat} claims are created. The subject usually is the username or email address, the \gls{jwt} ID is a unique identitfier, in the Jukebox project a \gls{guid} is used, and the Issued At claim contains the current timestamp in \gls{utc} time. Then all claims stored in the \lstcode{ClaimsIdentity} are added. These are claims defined by the web application and \zB could contain a claim which grants access to the administrativ section of the application. Then a \lstcode{JwtSecurityToken} object is created. For this the \lstcode{JwtTokenOptions} are used to set the expiration timespan, the issuer, and so on. Then a refresh token is created. For simplicity the Jukebox project uses a \gls{guid} as a refresh token. Finally a \lstcode{AuthToken} \gls{dto} object is created which is used to send the information back to the client. So far the \lstcode{JwtSecurityToken} is a C\# object which still needs to be serialized into a \gls{json} string. The serialization is handled by the \lstcode{JwtSecurityTokenHandler.WriteToken()} method. Both the \lstcode{JwtSecurityToken} and the \lstcode{JwtSecurityTokenHandler} classes are provided by the \gls{jwt} package.


\file{generateBasicAuthToken.cs}{Generating the JWT Token.}{NC_CSharp}

\Subsubsection[claimsAuth]{Claims-Based Authorization}

After a client is authenticated the \gls{jwt} token will be read and all claims will be extracted. These claims are used to check whether the client is authorized to execute an action. A claim describes an individual right or action this client posseses. It can also be proof of a piece of information about the client, such as his email address, birth date, or phone number.

For the Jukebox project, two custom claims were implemented. First, the \lstcode{UsernameClaim} which is used to store the username of a client. Second, the \lstcode{RoleClaim}. This claim is used to identify a client as \enquote{SystemAdmin}, \lstcode{IndexAdmin}, or \lstcode{PlayerAdmin} and grants the right to execute certain actions. Claims will be serialized when they are sent to client inside the \gls{jwt} token. To still identify a claim after it has been serialized, the claim needs a unique type which is saved as a string. By convention a \gls{url} is used. For example the \enquote{http://Jukebox/Claims/Security/Username} string is assigned to the \lstcode{UsernameClaim} type. \cite{claimsBasedAuth}

\Section{Custom Middlewares}

\Subsubsection[exceptionMiddleware]{Exception Middleware}

\Section{ASP.NET Core Websockets}

\Section{Remember these points}
