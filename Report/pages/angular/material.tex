% !TEX root=../../report.tex

\Section{Angular Material}

Angular Material is a framework, also developed by Google, which provides pre-built controls. These include buttons, trees, datepickers and many more. All of these controls are styled with the Google Material style guidelines in mind. To be able to use this framework, the developer has to install it via \gls{npm} or a similar package management tool. \cite{angularMaterial}

\Subsection{Components}
Each control is an Angular component. This means that controls can be used in the \gls{html} by inculding the corresponding tag, as shown in \mylineref{lst:navigation-bar.html}{navbar_mat_toolbar}. Any \gls{html} tag which starts with the \lstcode{mat-} prefix references an Angular Material control/component.

This prefix was changed from \lstcode{md-} to the current \lstcode{mat-}. At the same time, Angular Material changed how the components are organized into modules. Previously, there was a single module called \lstcode{MaterialModule} which became deprecated and was replaced by dedicated modules for each single control, \zB \lstcode{MatButtonModule}. The Jukebox project currently uses 17 different controls, which results in having to import 17 different modules. To keep the app.moudle.ts file tidy, a custom module was created. This so-called \lstcode{MaterialMetaModule} imports and exports all 17 \enquote{submodules}, so that the \lstcode{AppModule} only has to import this one meta module.

\file{dialog.ts}{Sample dialog in the SettingsComponent.}{JavaScript}

Many controls like buttons or the toolbar are only referenced in the \gls{html} because they don't contain much logic. These components are desinged to communicate through their events and properties. This can be achieved through bindings in the \gls{html} code (see \myref{subsubsec:bindings}). Especially for dialogs, a developer wants to have more control over how and when the dialog is displayed. Dialogs are also invoked through the \gls{ts}, for instance inside some method or event handler. Typically, the dialog contains some sort of question and the answer determines how the application should proceed. Since a dialog is a modal element which is always positioned as an overlay, it is unclear where the element should be placed in the \gls{dom}. Angular Material solves this by injecting the \lstcode{MatDialog} into the component's \gls{ts} file (\mylineref{lst:dialog.ts}{dialog_injected}). This means that the placement in the \gls{dom} is done by the framework and the developer doesn't have to worry about it.

A filepicker dialog was implemented for the Jukebox project. This dialog serves the purpose of selecting a folder which the server should use to index *.mp3 files. Once the user clicks the \enquote{addPath} button, a dialog is created. This is done via the \lstcode{MatDialog.open()} method, as shown in \mylineref{lst:dialog.ts}{dialog_open}. The \lstcode{MatDialog.open()} method requires the type of an Angular component as its first argument. This determines the component to be displayed as the dialog's content. In addition, a configuration object may be passed to the method. The configuration object is of type \lstcode{MatDialogConfig} and is used to configure the dialog's appearance. One of its properties is the \lstcode{data} property which allows the developer to pass an arbitrary object into the dialog. This feature was used to pass a custom configuration object of type \lstcode{FilePickerConfig} (\mylineref{lst:dialog.ts}{dialog_filePickerConfig}).

The \lstcode{MatDialog.open()} method returns a reference to the newly created dialog which is of type \lstcode{MatDialogRef<T>}. This class exposes certain methods to configure event handlers. Most notably, the \lstcode{afterClosed()} and \lstcode{afterOpen()} methods. These methods return \lstcode{Observable<R | undefined>} and \lstcode{Observable<void>}, respectively. The \lstcode{afterClosed()} method was used to retrieve the selected path from the \lstcode{FilePickerConfig} object and initiate an \gls{http} call to save this path.

\file{filePickerComponent.ts}{Excerpt from the \lstcode{FilePickerDialogComponent}.}{JavaScript}

Once the \lstcode{MatDialog.open()} method is called, the required component will be created. During that process all necessary objects will be injected into this component. At this point, the developer can request dialog-specific objects next to the service classes which the component needs to function. A reference to the displaying dialog is necessary in almost any case. For this purpose, the developer asks for an object of type \lstcode{MatDialogRef<T>} where \lstcode{T} is the type of the displayed component (\mylineref{lst:filePickerComponent.ts}{filePicker_dialogRef}). With this reference, it is possible to close the dialog from within the \gls{ts} code, as shown in line \ref{line:filePicker_close}. If a configuration object was passed, its data can be accessed via the \lstcode{@Inject()} decorator (\mylineref{lst:filePickerComponent.ts}{filePicker_config}). For this to work the \lstcode{MAT\_DIALOG\_DATA} argument must be passed into the decorator. \cite{matDialog}


\Subsection{Icons}

Using intuitive icons is a big part of the visual design of any application. There are many ways how icons can be encoded and used, \zB they can be images or vector graphics. Angular Material uses another, also popular method called \enquote{Font Icons}. The same concept is used by FontAwesome \cite{fontAwesome} and many others. A font usually displays some sort of letter but technically it is just a way of representing a scalable image. Icons are mostly used in buttons or menus which are all designed to work with some sort of font. Also, fonts are an old concept which means support for them is fairly good.

There are many ways to use the Material icon set. The Jukebox project mainly uses the \lstcode{<mat-icon />} tag (see \mylineref{lst:navigation-bar.html}{navbar_icon}), but it is also possible to associate \gls{css} classes with specific icons or use the \lstcode{<svg />} tag. It should be noted though, that the latter two examples are usually needed if the provided icons aren't sufficient or if \zB another icon font is used in addition. To use the Material icon set its font must be included. This was done via the \lstcode{@font-face} \gls{css} rule.

During the development of the Jukebox project, a bug was discovered which resulted in no icons being displayed. This only occurred in the Internet Explorer and Edge and was fixed by changing how icons are selected. Angular Material offers the possibility to use an icon's name to reference it inside the \gls{html} tag \zB \lstcode{<mat-icon>menu</mat-icon>}. Another method is to use the unicode explicitly. This method has the drawback, that it isn't obvious anymore what an icon represents or looks like by just looking at the \gls{html} code. Some users in the community have created command line tools, which integrate into the Angular \gls{cli} or work as standalone scripts, which replace all names with the corresponding unicodes. Since the focus for this thesis was towards compatibility between Electron and Angular, none of these tools were evaluated. \cite{materialIcons}
