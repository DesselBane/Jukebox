% !TEX root=../report.tex

\Chapter{Results}


The Jukebox project makes use of most of Electron's prominent features. These include the notification \gls{api}, the menu \gls{api}, the system tray \gls{api}, Electron's \gls{ipc} components, and a number of smaller features. None of these features is completly unusable given this specific combination of frameworks. Adaptations and third-party libraries were needed to make the communication between Electron's \glspl{api} and Angular's services work (\myref{sec:accessElectronApis}). A solution for connecting an Electron menu item with a click event handler which calls Angular \glspl{api} (\myref{sec:electronMenus}) is neither documented in the Electron nor in the Angular manual. Research provided little information on this topic, apparently this use case is not very common. Compared to the challenges posed by the menu \gls{api}, Electron's \gls{ipc} \gls{api} works very well, even the communication back and forth between an Angular service inside a renderer process and Electron's main process is simple to implement and works as described in the documentation. In conclusion, even though not everything works without further adjustment, it is possible to use this combination of frameworks to create a platform-independent application.


Compared to a pure web application, the hybrid Electron approach does require more architectural decisions. It has to be considered whether the application shall be hosted as a web page in addition to being hosted through Electron or not. Electron's \glspl{api} abstract most of the low level \glspl{api} provided by the operating systems. Nonetheless, there are still \glspl{api} like the notification \gls{api} which require different implementations for each operating system. They can be abstracted, but the developer will have to implement these abstraction layers because they are not provided by the framework. Additionally, if the application is hosted in a web environment, some \glspl{api} might not be accessible because they require special hardware or other components not available there. Therefore, these functionalities require a modularized approach in order to easily exclude them in a web environment. One such example from the Jukebox project are menus. When hosted as an Electron application, Electron's menu \gls{api} is used. The web page version of the application uses Angular menu items. One solution is to always use Angular menu items because they are available in both environments. However, the Jukebox project uses an Angular service to abstract menu items. This service then checks the environment and applies the correct menu items for each environment.

The obvious benefit of this hybrid approach as opposed to a pure web application is its offline usability.  The main advantage, howerever, is the set of numerous and more comprehensive features available. Although some of these features require native node modules, the possibility to implement them at all is well worth the effort involved. Many native node modules are provided through various web portals. For other, more specific use cases, a custom implementation is needed.


A reason for using a pure desktop application might be to avoid performance problems. This is due to the fact that it is difficult to implement multithreading using the Electron framework. \gls{js} generally runs in one single thread. Libraries like RxJS might give the impression to be multithreaded because they use terminology like awaitables, and so forth, but this is not the case. They still work with just one thread and use an event loop to simulate multithreading. It is possible to create more than one thread which is usually referred to as a \enquote{Web Worker}, but there are no means to synchronize two threads using locks, semaphores, or monitors \cite{jsWebWorkers}. Electron's documentation also discourages the use of native node modules inside a web worker because most of the native node modules were not designed to work in a multithreaded environment \cite{electronMultithreading}. Although performance is generally speaking an important point, many applications will work well within these limitations. It is also possible to use Electron for most of the application and move only the performance-critical code into a native node module, or, as it was done in the Jukebox project, into an \gls{asp} C\# back-end.

The biggest benefit of using Electron is the single code base for all operating systems. Many traditional desktop application frameworks are limited to a single platform and none have the additional benefit of also producing a web page. (many web developers)
